(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{514:function(v,_,l){"use strict";l.r(_);var i=l(56),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"redis"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[v._v("#")]),v._v(" redis")]),v._v(" "),l("ol",[l("li",[v._v("为什么要用缓存 （内存缓存）\n"),l("ol",[l("li",[v._v("缓解关系型数据库并发访问压力：热点数据")]),v._v(" "),l("li",[v._v("减少响应时间：内存IO速度比磁盘快")]),v._v(" "),l("li",[v._v("提升吞吐量：Redis等内存数据库单机就可以支持很大并发")])])]),v._v(" "),l("li",[v._v("redis和memcached主要区别\n"),l("ol",[l("li",[v._v("整体类型\n"),l("ol",[l("li",[v._v("r 支持内存 非关系型数据库")]),v._v(" "),l("li",[v._v("m 支持内存  key-value")])])]),v._v(" "),l("li",[v._v("数据类型\n"),l("ol",[l("li",[v._v("r  string list set zset hash")]),v._v(" "),l("li",[v._v("m  文本型 二进制类型")])])]),v._v(" "),l("li",[v._v("操作类型\n"),l("ol",[l("li",[v._v("r  单个操作、批量操作、事务支持（弱事务、结合lua)、每个类型不同的curd")]),v._v(" "),l("li",[v._v("m  curd 少量其它命令")])])]),v._v(" "),l("li",[v._v("附加功能\n"),l("ol",[l("li",[v._v("r 发布\\订阅、主从高可用（哨兵、故障转移）、序列化支持、支持lua脚本")]),v._v(" "),l("li",[v._v("m 多线程服务支持")])])]),v._v(" "),l("li",[v._v("网络IO模型\n"),l("ol",[l("li",[v._v("r 执行命令-单线程、网络操作-多线程")]),v._v(" "),l("li",[v._v("m 多线程、非阻塞的IO模式")])])]),v._v(" "),l("li",[v._v("持久化\n"),l("ol",[l("li",[v._v("r RDB、AOF")]),v._v(" "),l("li",[v._v("m 不支持")])])])])]),v._v(" "),l("li",[v._v("redis常用数据类型与使用场景\n"),l("ol",[l("li",[v._v("string: 用来实现简单的kv键值对存储，比如计数器")]),v._v(" "),l("li",[v._v("list：实现双向链表，比如用户的关注，粉丝列表")]),v._v(" "),l("li",[v._v("hash：用来存储彼此相关信息的键值对")]),v._v(" "),l("li",[v._v("set：存储不重复元素，比如用户的关注者")]),v._v(" "),l("li",[v._v("sorted set: 实时信息排行榜")])])]),v._v(" "),l("li",[v._v("redis各种内置类型的实现方式\n"),l("ol",[l("li",[v._v("string: 整数或者sds (simple dynamic string)")]),v._v(" "),l("li",[v._v("list: ziplist或者double linked list")]),v._v(" "),l("li",[v._v("hash: ziplist或者hashtable")]),v._v(" "),l("li",[v._v("set：intset或者hashtable")]),v._v(" "),l("li",[v._v("sortedset：skiplist跳跃表")])])]),v._v(" "),l("li",[v._v("redis持久化\n"),l("ol",[l("li",[v._v("快照方式：把数据快照放在磁盘二进制文件中，dump.rdb")]),v._v(" "),l("li",[v._v("AOF(Append Only File): 每一个写命令追加到appendonly.aof中")]),v._v(" "),l("li",[v._v("可以通过修改redis配置实现")])])]),v._v(" "),l("li",[v._v('redis"事务"\n'),l("ol",[l("li",[v._v("将多个请求打包，一次性、按顺序执行多个命令的机制")]),v._v(" "),l("li",[v._v("通过multi,exec,watch等命令实现事务功能\n"),l("ol",[l("li",[v._v("multi 命令开始")]),v._v(" "),l("li",[v._v("要执行的一组命令")]),v._v(" "),l("li",[v._v("exec 命令结束")])])]),v._v(" "),l("li",[v._v("redis-py pipeline=conn.pipeline(transaction=True)")]),v._v(" "),l("li",[v._v("redis的事务功能很弱，在事务回滚机制上，只能进行基本的语法错误判断。事务不支持回滚")]),v._v(" "),l("li",[v._v("原理：服务端的行为，用户执行multi命令时，服务器会将命令缓存起来，直到用户执行exec,才按顺序执行命令")])])]),v._v(" "),l("li",[v._v("redis如何实现分布式锁？\n"),l("ol",[l("li",[v._v("使用setnx实现加锁，可以同时通过expire添加超时时间")]),v._v(" "),l("li",[v._v("锁的value值可以使用一个随机的uuid或者特定的命名")]),v._v(" "),l("li",[v._v("释放锁的时候，通过uuid判断是否是该锁，是则执行delete释放锁")])])]),v._v(" "),l("li",[v._v("使用缓存的模式？\n"),l("ol",[l("li",[v._v("Cache Aside: 同时更新缓存和数据库")]),v._v(" "),l("li",[v._v("Read/Write Through: 先更新缓存，缓存负责同步更新数据库")]),v._v(" "),l("li",[v._v("Write Behind Caching: 先更新缓存，缓存定期异步更新数据库")])])]),v._v(" "),l("li",[v._v("如何解决缓存穿透问题？\n"),l("ol",[l("li",[v._v("原因：\n"),l("ol",[l("li",[v._v("大量查询不到的数据请求落到后端数据库，数据库压力增大")]),v._v(" "),l("li",[v._v("由于大量缓存查不到就去数据库取，数据库也没有要查的数据")])])]),v._v(" "),l("li",[v._v("解决：")]),v._v(" "),l("li",[v._v("对于没有查询到返回为None的数据也缓存")]),v._v(" "),l("li",[v._v("插入数据的时候删除相应缓存，或者设置较短的超时时间")]),v._v(" "),l("li",[v._v("布隆过滤器与Bitmaps\n"),l("ol",[l("li",[v._v("用来判断一个元素是否在一个集合中")]),v._v(" "),l("li",[v._v("由一个二进制数组和一个hash算法组成")]),v._v(" "),l("li",[v._v("误判问题\n"),l("ol",[l("li",[v._v("本质hash冲突")]),v._v(" "),l("li",[v._v("通过hash计算在数组上不一定在集合")]),v._v(" "),l("li",[l("strong",[v._v("通过hash计算不在数组的一定不在集合")]),v._v(" "),l("ol",[l("li",[v._v("优化方案")]),v._v(" "),l("li",[v._v("增大数组")]),v._v(" "),l("li",[v._v("增加hash函数")])])])])])])])])]),v._v(" "),l("li",[v._v("如何解决缓存击穿问题？\n"),l("ol",[l("li",[v._v("某些非常热点的数据key过期，大量请求打到后端数据库")]),v._v(" "),l("li",[v._v("热点数据key失效导致大量请求打到数据库增加数据库压力")]),v._v(" "),l("li",[v._v("分布式锁：获取锁的线程从数据库拉数据更新缓存，其他线程等待")]),v._v(" "),l("li",[v._v("异步后台更新：后台任务针对过期的key自动刷新")])])]),v._v(" "),l("li",[v._v("如何解决缓存雪崩问题？\n"),l("ol",[l("li",[v._v("缓存不可用 redis挂了 -> 解决：集群")]),v._v(" "),l("li",[v._v("大量缓存key同时失效，大量请求直接打到数据库\n"),l("ol",[l("li",[v._v("多级缓存：不同级别的key设置不同的超时时间")]),v._v(" "),l("li",[v._v("随机超时：key的超时时间随机设置，防止同时超时")]),v._v(" "),l("li",[v._v("架构层：提升系统可用性。监控、报警完善")])])])])]),v._v(" "),l("li",[v._v("redis6.0前为什么单线程\n"),l("ol",[l("li",[v._v("cpu不是瓶颈，主要受限内存、网络")]),v._v(" "),l("li",[v._v("pipeline （命令批量）每秒100w个请求")]),v._v(" "),l("li",[v._v("单线程的内部开发维护成本低")]),v._v(" "),l("li",[v._v("如果是多线程，会涉及到线程切换、加锁\\解锁、导致死锁问题")]),v._v(" "),l("li",[v._v("惰性Rehash(渐进性式的Rehash)")]),v._v(" "),l("li",[v._v("一般的情况，单线程redis就够用了")])])]),v._v(" "),l("li",[v._v("redis为什么快\n"),l("ol",[l("li",[v._v("纯内存操作")]),v._v(" "),l("li",[v._v("单线程避免上下文切换")]),v._v(" "),l("li",[v._v("渐进式rehash、缓存时间戳")])])]),v._v(" "),l("li",[v._v("redis6.0为什么引入多线程\n"),l("ol",[l("li",[v._v("单线程就够了。数据->内存 响应时间 100ns\n"),l("ol",[l("li",[v._v("比较小的数据包，8w~10w qsp（极限值）")])])]),v._v(" "),l("li",[v._v("大的公司，需要更大的QPS，IO的多线程（内部执行命令还是单线程）")]),v._v(" "),l("li",[v._v("为什么不采用分布式架构----很大的缺点\n"),l("ol",[l("li",[v._v("服务数量多，维护成本很高")]),v._v(" "),l("li",[v._v("redis命令，不适用数据分区")]),v._v(" "),l("li",[v._v("数据倾斜，重新分配、扩容、缩容，更加复杂")])])]),v._v(" "),l("li",[v._v("多线程任务 分摊到Redis同步IO中读写 负载")])])]),v._v(" "),l("li",[v._v("Redis有哪些高级功能\n"),l("ol",[l("li",[v._v("Redis的慢查询\n"),l("ol",[l("li",[v._v("快速定位系统存在的慢操作")])])]),v._v(" "),l("li",[v._v("pipeline\n"),l("ol",[l("li",[v._v("管道 批量操作")])])]),v._v(" "),l("li",[v._v("事务")]),v._v(" "),l("li",[v._v("Lua")]),v._v(" "),l("li",[v._v("持久化\n"),l("ol",[l("li",[v._v("rdb")]),v._v(" "),l("li",[v._v("aof")])])]),v._v(" "),l("li",[v._v("缓存策略")])])]),v._v(" "),l("li",[v._v("主重复制")]),v._v(" "),l("li",[v._v("高可用集群搭建")]),v._v(" "),l("li",[v._v("为什么要用redis\n"),l("ol",[l("li",[v._v("高性能")]),v._v(" "),l("li",[v._v("高并发")])])]),v._v(" "),l("li",[v._v("reids的过期策略和淘汰策略\n"),l("ol",[l("li",[v._v("定期删除\n"),l("ol",[l("li",[v._v("从库是从主库同步的")])])]),v._v(" "),l("li",[v._v("惰性删除\n"),l("ol",[l("li",[v._v("客户端访问这个key的时候，检查过期时间，过期了就立即删除，不返回任何东西")])])]),v._v(" "),l("li",[v._v("缓存淘汰算法\n"),l("ol",[l("li",[v._v("maxmemory")]),v._v(" "),l("li",[v._v("volatile-lru")]),v._v(" "),l("li",[v._v("volatile-ttl")]),v._v(" "),l("li",[v._v("volatile-random")]),v._v(" "),l("li",[v._v("allkeys-lru")]),v._v(" "),l("li",[v._v("allkeys-random")])])])])]),v._v(" "),l("li",[v._v("LRU算法\n"),l("ol",[l("li",[v._v("维护一个链表，元素按照一定顺序进行排列，满了就会删除尾部的元素，当元素被访问时，元素在链表的位置就会被移动到表头，元素排列的顺序就元素最近被访问的时间顺序")]),v._v(" "),l("li",[v._v("redis的近似lru算法")]),v._v(" "),l("li",[v._v("不使用lru算法是因为需要消耗大量的额外内存，需要对现有的数据结构进行较大的改造")]),v._v(" "),l("li",[v._v("在现有数据结构的基础上使用随机采样法来淘汰元素，给每个key添加一个额外字段24bit，记录最后一次被访问的时间戳，redis执行写操作时，发现内存超过maxmemory，就会执行lru淘汰算法，随机采用出5个（maxmemory-sample)key，然后淘汰到最旧的key。")])])]),v._v(" "),l("li",[v._v("redis中消息队列实现方式\n"),l("ol",[l("li",[v._v("基于List的LPUSH+BRPOP的实现\n"),l("ol",[l("li",[v._v("足够简单，消息延迟几乎为零，但是需要处理空闲连接的问题")]),v._v(" "),l("li",[v._v("如果线程一直阻塞，redis客户端的连接就成了闲置连接，长时间闲置，服务器一般会主动断开连接，减少闲置资源占用， blpop/brpop会抛出异常")]),v._v(" "),l("li",[v._v("消费者做ack麻烦，不能保证消费者消费消息后是否处理成功的问题，通常需要维护一个pending列表，保证消息处理确认")]),v._v(" "),l("li",[v._v("不能做广播模式，如pub/sub,消息发布/订阅模型;不能重复消费，一旦消费就会被删除;不支持分组消费")])])]),v._v(" "),l("li",[v._v("基于Sorted-Set的实现\n"),l("ol",[l("li",[v._v("多用来实现延迟队列，（当然也可以实现有序的普通的消息队列），消费者无法阻塞的获取消息，只能轮询，不允许重复消息")])])]),v._v(" "),l("li",[v._v("PUB/SUB，发布/订阅模式\n"),l("ol",[l("li",[v._v("典型的广播模式，一个消息可以发布到多个消费者;")]),v._v(" "),l("li",[v._v("多信道订阅，消费者可以同时订阅多个信道消息")]),v._v(" "),l("li",[v._v("消息即时发送，消息不用等待消费者读取，消费者会自动接收到信道发布的消息")]),v._v(" "),l("li",[v._v("缺点：\n"),l("ol",[l("li",[v._v("消息一旦发布，不能接收，发布时若客户端不在线，则消息丢失")]),v._v(" "),l("li",[v._v("不保证每个消费者接收的时间是一致的；若消费者客户端出现消息积压，到一定程度，会被强制断开，导致消息意外丢失。通常发生在消息的生产远大于消费速度时。")])])]),v._v(" "),l("li",[v._v("Pub/Sub模式不适合做消息存储，消息挤压类的业务，而是擅长处理广播，即时通讯，即时反馈的业务。")])])]),v._v(" "),l("li",[v._v("基于stream类型的实现\n"),l("ol",[l("li",[v._v("redis5.0新增的支持多播的可持久化的消息队列\n"),l("ol",[l("li",[v._v("生产者API、消费者API、消息Broker,消息的确认机制等等")])])]),v._v(" "),l("li",[v._v("消息太多怎么办\n"),l("ol",[l("li",[v._v("定长Stream功能。xadd指令提供一个定长长度maxlen，就可以将老的消息干掉，确保最多不超过指定长度")])])]),v._v(" "),l("li",[v._v("消息如果忘记ACK\n"),l("ol",[l("li",[v._v("在每个消费者结构中保存了正在处理中的消息ID列表PEL，如果消费者收了消息但是没有回复ack,就会导致PEL列表不断增长。")])])]),v._v(" "),l("li",[v._v("PEL如何避免消息丢失\n"),l("ol",[l("li",[v._v("断开重连后，xreadgroup的起始消息ID 0-0,表示读取所有的PEL消息以及自last_delivered_id之后的新消息")])])]),v._v(" "),l("li",[v._v("死信问题\n"),l("ol",[l("li",[v._v("消息老是消费不掉 XPENDING可以查询到")]),v._v(" "),l("li",[v._v("XDEL删除掉一个消息，XACK将这个消息标记为处理完毕")])])]),v._v(" "),l("li",[v._v("stream高可用\n"),l("ol",[l("li",[v._v("建立在主从复制的基础上，跟其它结构没区别")]),v._v(" "),l("li",[v._v("failover发生时，可能会丢极小部分数据")])])]),v._v(" "),l("li",[v._v("分区partiotion\n"),l("ol",[l("li",[v._v("没有原生支持分区能力")]),v._v(" "),l("li",[v._v("可以分配多个stream,然后在客户端生成消息时用不同的策略发送到不同stream")])])])])])])]),v._v(" "),l("li",[v._v("什么是bigkey？会有什么影响？\n"),l("ol",[l("li",[v._v("key对应的value所在的内存空间比较大\n"),l("ol",[l("li",[v._v("字符串 最大512m")]),v._v(" "),l("li",[v._v("列表 value最多存储2^32-1个元素")])])]),v._v(" "),l("li",[v._v("危害\n"),l("ol",[l("li",[v._v("内存空间不平衡")]),v._v(" "),l("li",[v._v("超时阻塞")]),v._v(" "),l("li",[v._v("网络拥塞")]),v._v(" "),l("li",[v._v("bigkey的存在并不是完全致命的，主要还是看是否会被频繁访问")])])])])]),v._v(" "),l("li",[v._v("redis如何解决key冲突\n"),l("ol",[l("li",[v._v("业务隔离")]),v._v(" "),l("li",[v._v("key的设计\n"),l("ol",[l("li",[v._v("业务模块+系统名称+关键 biz-pay-orderid-1, userid")])])]),v._v(" "),l("li",[v._v("分布式锁\n"),l("ol",[l("li",[v._v("多个客户端，并发写key")])])])])]),v._v(" "),l("li",[v._v("如何提高缓存命中率？\n"),l("ol",[l("li",[v._v("提前加载")]),v._v(" "),l("li",[v._v("增加缓存的存储空间，提高缓存的数据量、提高命中率")]),v._v(" "),l("li",[v._v("调整缓存的存储类型？")]),v._v(" "),l("li",[v._v("提升缓存的更新频次")])])]),v._v(" "),l("li",[v._v("持久化\n"),l("ol",[l("li",[v._v("RDB  Redis DataBase\n"),l("ol",[l("li",[v._v("生成快照保存到硬盘")]),v._v(" "),l("li",[v._v("save")]),v._v(" "),l("li",[v._v("bgsave")]),v._v(" "),l("li",[l("code",[v._v("dbfilename dump-${port}.rdb")])]),v._v(" "),l("li",[l("code",[v._v("dir ./")])])])]),v._v(" "),l("li",[v._v("AOF append only file\n"),l("ol",[l("li",[v._v("以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的，主要是解决实时性的问题，性能没有rdb高")]),v._v(" "),l("li",[l("code",[v._v("appendonly yes")]),v._v(" 默认开启")]),v._v(" "),l("li",[l("code",[v._v('appendfilename "appendonly.aof')])]),v._v(" "),l("li",[l("code",[v._v("appendfsync: no/always/everysec")]),v._v(" 不执行/每次写入都执行/每秒执行一次")]),v._v(" "),l("li",[l("code",[v._v("redis-check-aof --fix")]),v._v("命令来修复破损的AOF文件")])])]),v._v(" "),l("li",[v._v("RDB-AOF混合持久化\n"),l("ol",[l("li",[v._v("同时启用AOF和RDB")])])])])]),v._v(" "),l("li",[v._v("为什么redis需要把所有的数据放到内存中？\n"),l("ol",[l("li",[v._v("内存读写速度快")])])]),v._v(" "),l("li",[v._v("如何保证缓存与数据库双写时的数据一致性?")]),v._v(" "),l("li",[v._v("redis集群方案应该怎么做?")]),v._v(" "),l("li",[v._v("redis集群方案什么情况下会导致集群不可用")]),v._v(" "),l("li",[v._v("redis哈希槽的概念")]),v._v(" "),l("li",[v._v("redis集群写操作会有丢失吗？为什么")]),v._v(" "),l("li",[v._v("redis常见性能问题和解决方案有哪些?")]),v._v(" "),l("li",[v._v("热点数据和冷数据是什么?")]),v._v(" "),l("li",[v._v("什么情况下可能会导致redis阻塞\n"),l("ol",[l("li",[v._v("客户端 阻塞 命令 keys* Hgetall smembers 时间复杂度 O(N)")]),v._v(" "),l("li",[v._v("BIGkey删除 zset (100万的元素 删除2s)")]),v._v(" "),l("li",[v._v("清空库 flushdb flushall")]),v._v(" "),l("li",[v._v("AOF日志同步写， 记录AOF日志 大量的写操作  1个同步写磁盘耗时1-2ms")]),v._v(" "),l("li",[v._v("从库 加载RDB文件")])])]),v._v(" "),l("li",[v._v("什么时候选择redis，什么时候选择memcached\n"),l("ol",[l("li",[v._v("redis功能更加强大 kv模式 string/list/hash/set/zset  memcache kv简单存储")]),v._v(" "),l("li",[v._v("redis有持久化 memcache 不支持持久化")]),v._v(" "),l("li",[v._v("内存管理：\n"),l("ol",[l("li",[v._v("r 过期、内存淘汰策略")]),v._v(" "),l("li",[v._v("m 预分配池的管理，内存slab块 增长因子")]),v._v(" "),l("li",[v._v("redis适合做数据存储，memcache缓存")])])]),v._v(" "),l("li",[v._v("io角度\n"),l("ol",[l("li",[v._v("多路复用io   命令 单线程， 子命令 锁冲突")]),v._v(" "),l("li",[v._v("非阻塞的IO多路复用")])])])])]),v._v(" "),l("li",[v._v("redis过期策略都有哪些？LRU算法")])])])}),[],!1,null,null,null);_.default=e.exports}}]);